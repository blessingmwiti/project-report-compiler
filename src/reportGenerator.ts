import * as vscode from 'vscode';
import { DataManager, ProjectData, CommitData } from './dataManager';

export class ReportGenerator {
    constructor(private dataManager: DataManager) {}

    public async generateReport(startDate: Date, endDate: Date): Promise<string> {
        const config = vscode.workspace.getConfiguration('projectReportCompiler');
        const format = config.get('reportFormat', 'markdown') as string;

        const commitsData = await this.dataManager.getCommitsInDateRange(startDate, endDate);
        
        if (commitsData.length === 0) {
            return this.formatNoDataMessage(startDate, endDate, format);
        }

        switch (format) {
            case 'html':
                return this.generateHtmlReport(commitsData, startDate, endDate);
            case 'txt':
                return this.generatePlainTextReport(commitsData, startDate, endDate);
            default:
                return this.generateMarkdownReport(commitsData, startDate, endDate);
        }
    }

    public async generateProjectReport(project: ProjectData): Promise<string> {
        const config = vscode.workspace.getConfiguration('projectReportCompiler');
        const format = config.get('reportFormat', 'markdown') as string;

        switch (format) {
            case 'html':
                return this.generateProjectHtmlReport(project);
            case 'txt':
                return this.generateProjectPlainTextReport(project);
            default:
                return this.generateProjectMarkdownReport(project);
        }
    }

    private generateMarkdownReport(commitsData: { project: string; commits: CommitData[] }[], startDate: Date, endDate: Date): string {
        const report = [];
        
        // Header
        report.push(`Work Report`);
        report.push('');
        report.push(`Period: ${this.formatDate(startDate)} to ${this.formatDate(endDate)}`);
        report.push(`Generated: ${this.formatDateTime(new Date())}`);
        report.push('');

        if (commitsData.length === 0) {
            report.push('No commits found for this period.');
            report.push('');
            report.push('Generated by: Project Report Compiler');
            return report.join('\n');
        }

        // Project details
        report.push(`Project Details`);
        report.push('');

        for (const projectData of commitsData) {
            report.push(`${this.capitalizeProjectName(projectData.project)}`);

            // Get all commit messages for this project
            for (const commit of projectData.commits) {
                const cleanMessage = this.cleanCommitMessage(commit.message);
                report.push(cleanMessage);
            }
            
            report.push('');
        }

        // Add signature
        report.push('Generated by: Project Report Compiler');

        return report.join('\n');
    }

    private generateProjectMarkdownReport(project: ProjectData): string {
        const report = [];
        
        report.push(`Project Report: ${this.capitalizeProjectName(project.name)}`);
        report.push('');
        report.push(`Path: ${project.path}`);
        report.push(`Total Commits: ${project.commits.length}`);
        report.push(`Generated: ${this.formatDateTime(new Date())}`);
        report.push('');

        if (project.commits.length === 0) {
            report.push('No commits found for this project.');
            report.push('');
            report.push('Generated by: Project Report Compiler');
            return report.join('\n');
        }

        // Recent activity (last 30 days)
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        
        const recentCommits = project.commits.filter(commit => 
            new Date(commit.date) >= thirtyDaysAgo
        );

        report.push(`Recent Activity (Last 30 Days)`);
        report.push('');

        if (recentCommits.length > 0) {
            for (const commit of recentCommits) {
                const cleanMessage = this.cleanCommitMessage(commit.message);
                report.push(cleanMessage);
            }
        } else {
            report.push('No recent commits in the last 30 days.');
        }
        
        report.push('');
        report.push('Generated by: Project Report Compiler');

        return report.join('\n');
    }

    private generateHtmlReport(commitsData: { project: string; commits: CommitData[] }[], startDate: Date, endDate: Date): string {
        const report = [];
        
        // Start HTML document with styling
        report.push('<div style="font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6;">');
        
        // Header
        report.push('<h1 style="color: #2563eb; margin-bottom: 8px;">Work Report</h1>');
        report.push('<p style="margin-bottom: 4px;">');
        report.push(`<strong>Period:</strong> ${this.formatDate(startDate)} to ${this.formatDate(endDate)}`);
        report.push('</p>');
        report.push('<p style="margin-bottom: 20px;">');
        report.push(`<strong>Generated:</strong> ${this.formatDateTime(new Date())}`);
        report.push('</p>');

        if (commitsData.length === 0) {
            report.push('<p>No commits found for this period.</p>');
            report.push('<p style="margin-top: 20px;"><strong>Generated by:</strong> Project Report Compiler</p>');
            report.push('</div>');
            return report.join('\n');
        }

        // Project details
        report.push('<h2 style="color: #374151; margin-top: 24px; margin-bottom: 12px;">Project Details</h2>');

        for (const projectData of commitsData) {
            report.push(`<h3 style="color: #4b5563; margin-top: 20px; margin-bottom: 8px;">${this.capitalizeProjectName(projectData.project)}</h3>`);

            // Get all commit messages for this project
            for (const commit of projectData.commits) {
                const cleanMessage = this.cleanCommitMessage(commit.message);
                report.push(`<p style="margin-bottom: 4px; margin-left: 0px;">${cleanMessage}</p>`);
            }
            
            report.push('<br>');
        }

        // Add signature
        report.push('<p style="margin-top: 20px;"><strong>Generated by:</strong> Project Report Compiler</p>');
        report.push('</div>');

        return report.join('\n');
    }

    private generatePlainTextReport(commitsData: { project: string; commits: CommitData[] }[], startDate: Date, endDate: Date): string {
        const report = [];
        
        // Header
        report.push(`Work Report`);
        report.push('');
        report.push(`Period: ${this.formatDate(startDate)} to ${this.formatDate(endDate)}`);
        report.push(`Generated: ${this.formatDateTime(new Date())}`);
        report.push('');

        if (commitsData.length === 0) {
            report.push('No commits found for this period.');
            report.push('');
            report.push('Generated by: Project Report Compiler');
            return report.join('\n');
        }

        // Project details
        report.push(`Project Details`);
        report.push('');

        for (const projectData of commitsData) {
            report.push(`${this.capitalizeProjectName(projectData.project)}`);

            // Get all commit messages for this project
            for (const commit of projectData.commits) {
                const cleanMessage = this.cleanCommitMessage(commit.message);
                report.push(cleanMessage);
            }
            
            report.push('');
        }

        // Add signature
        report.push('Generated by: Project Report Compiler');

        return report.join('\n');
    }

    private generateProjectHtmlReport(project: ProjectData): string {
        const markdownReport = this.generateProjectMarkdownReport(project);
        return this.generateHtmlReport([{ project: project.name, commits: project.commits }], new Date(0), new Date());
    }

    private generateProjectPlainTextReport(project: ProjectData): string {
        const report = [];
        
        report.push(`Project Report: ${this.capitalizeProjectName(project.name)}`);
        report.push('');
        report.push(`Path: ${project.path}`);
        report.push(`Total Commits: ${project.commits.length}`);
        report.push(`Generated: ${this.formatDateTime(new Date())}`);
        report.push('');

        if (project.commits.length === 0) {
            report.push('No commits found for this project.');
            report.push('');
            report.push('Generated by: Project Report Compiler');
            return report.join('\n');
        }

        // Recent activity (last 30 days)
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        
        const recentCommits = project.commits.filter(commit => 
            new Date(commit.date) >= thirtyDaysAgo
        );

        report.push(`Recent Activity (Last 30 Days)`);
        report.push('');

        if (recentCommits.length > 0) {
            for (const commit of recentCommits) {
                const cleanMessage = this.cleanCommitMessage(commit.message);
                report.push(cleanMessage);
            }
        } else {
            report.push('No recent commits in the last 30 days.');
        }
        
        report.push('');
        report.push('Generated by: Project Report Compiler');

        return report.join('\n');
    }

    private formatNoDataMessage(startDate: Date, endDate: Date, format: string): string {
        const message = `No commits found between ${this.formatDate(startDate)} and ${this.formatDate(endDate)}.`;
        
        switch (format) {
            case 'html':
                return `<div style="font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6;">
                    <h1 style="color: #2563eb; margin-bottom: 8px;">Work Report</h1>
                    <p style="margin-bottom: 4px;"><strong>Period:</strong> ${this.formatDate(startDate)} to ${this.formatDate(endDate)}</p>
                    <p style="margin-bottom: 20px;"><strong>Generated:</strong> ${this.formatDateTime(new Date())}</p>
                    <p>${message}</p>
                    <p style="margin-top: 20px;"><strong>Generated by:</strong> Project Report Compiler</p>
                </div>`;
            case 'txt':
                return `Work Report\n\nPeriod: ${this.formatDate(startDate)} to ${this.formatDate(endDate)}\nGenerated: ${this.formatDateTime(new Date())}\n\n${message}\n\nGenerated by: Project Report Compiler`;
            default:
                return `Work Report\n\nPeriod: ${this.formatDate(startDate)} to ${this.formatDate(endDate)}\nGenerated: ${this.formatDateTime(new Date())}\n\n${message}\n\nGenerated by: Project Report Compiler`;
        }
    }

    private groupCommitsByDate(commits: CommitData[]): { [date: string]: CommitData[] } {
        const groups: { [date: string]: CommitData[] } = {};
        
        for (const commit of commits) {
            const date = this.formatDate(new Date(commit.date));
            if (!groups[date]) {
                groups[date] = [];
            }
            groups[date].push(commit);
        }
        
        // Sort dates descending
        const sortedGroups: { [date: string]: CommitData[] } = {};
        const sortedDates = Object.keys(groups).sort((a, b) => new Date(b).getTime() - new Date(a).getTime());
        
        for (const date of sortedDates) {
            // Sort commits within each date by time descending
            groups[date].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
            sortedGroups[date] = groups[date];
        }
        
        return sortedGroups;
    }

    private getDailyActivity(commitsData: { project: string; commits: CommitData[] }[], startDate: Date, endDate: Date): { [date: string]: { commits: number; projects: string[]; files: number } } {
        const activity: { [date: string]: { commits: number; projects: string[]; files: number } } = {};
        
        // Initialize all dates in range
        const currentDate = new Date(startDate);
        while (currentDate <= endDate) {
            const dateStr = this.formatDate(currentDate);
            activity[dateStr] = { commits: 0, projects: [], files: 0 };
            currentDate.setDate(currentDate.getDate() + 1);
        }
        
        // Populate with actual data
        for (const projectData of commitsData) {
            for (const commit of projectData.commits) {
                const dateStr = this.formatDate(new Date(commit.date));
                if (activity[dateStr]) {
                    activity[dateStr].commits++;
                    activity[dateStr].files += commit.files.length;
                    if (!activity[dateStr].projects.includes(this.capitalizeProjectName(projectData.project))) {
                        activity[dateStr].projects.push(this.capitalizeProjectName(projectData.project));
                    }
                }
            }
        }
        
        return activity;
    }

    private calculateProjectStats(project: ProjectData): {
        totalFiles: number;
        totalAdditions: number;
        totalDeletions: number;
        firstCommit: string;
        lastCommit: string;
    } {
        let totalFiles = 0;
        let totalAdditions = 0;
        let totalDeletions = 0;
        let firstCommit = project.commits[0]?.date || new Date().toISOString();
        let lastCommit = project.commits[0]?.date || new Date().toISOString();

        for (const commit of project.commits) {
            totalFiles += commit.files.length;
            
            for (const file of commit.files) {
                totalAdditions += file.additions;
                totalDeletions += file.deletions;
            }

            const commitDate = new Date(commit.date);
            if (commitDate < new Date(firstCommit)) {
                firstCommit = commit.date;
            }
            if (commitDate > new Date(lastCommit)) {
                lastCommit = commit.date;
            }
        }

        return {
            totalFiles,
            totalAdditions,
            totalDeletions,
            firstCommit,
            lastCommit
        };
    }

    private summarizeFiles(files: { filename: string; additions: number; deletions: number }[]): string {
        if (files.length === 0) {
            return 'No files';
        }

        if (files.length === 1) {
            const file = files[0];
            return `${file.filename} (+${file.additions}/-${file.deletions})`;
        }

        const totalAdditions = files.reduce((sum, f) => sum + f.additions, 0);
        const totalDeletions = files.reduce((sum, f) => sum + f.deletions, 0);
        
        return `${files.length} files (+${totalAdditions}/-${totalDeletions})`;
    }

    private cleanCommitMessage(message: string): string {
        // Clean up commit message for display
        return message
            .split('\n')[0] // Take only the first line
            .trim()
            .replace(/^(feat|fix|docs|style|refactor|test|chore)(\(.+?\))?:\s*/i, '') // Remove conventional commit prefixes
            .replace(/^\w+:\s*/, ''); // Remove other prefixes like "update: "
    }

    private capitalizeProjectName(name: string): string {
        return name
            .split('-')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }

    private formatDate(date: Date): string {
        return date.toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
    }

    private formatDateTime(date: Date): string {
        return date.toLocaleString('en-US', {
            weekday: 'short',
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }

    private formatTime(date: Date): string {
        return date.toLocaleTimeString('en-US', {
            hour: '2-digit',
            minute: '2-digit'
        });
    }
}
